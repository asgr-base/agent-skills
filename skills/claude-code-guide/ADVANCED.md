# Claude Code 応用編詳細

## Context & Memory Management

### セッション間メモリ共有

進捗を要約してチェックし、`.claude`フォルダ内の`.tmp`ファイルに保存し、セッション終了まで追記するスキルまたはコマンドが最適。翌日にはそれをコンテキストとして使用し、中断したところから再開。新しいセッションごとに新しいファイルを作成し、古いコンテキストで新しい作業を汚染しないようにする。

最終的にこれらのセッションログの大きなフォルダができる。意味のある場所にバックアップするか、不要なセッション会話を削除する。

Claudeが現在の状態を要約するファイルを作成。レビューし、必要に応じて編集を依頼し、新しく開始。新しい会話にはファイルパスを提供するだけ。コンテキスト制限に達して複雑な作業を続ける必要がある場合に特に有用。

**セッションファイルに含めるべき内容**:
- 何のアプローチが成功したか（証拠付きで検証可能）
- 試行したが失敗したアプローチ
- 未試行のアプローチ
- 残っているタスク

**セッションストレージ例**:
```
~/.claude/sessions/
  2026-01-17-damm-research.tmp
  2026-01-19-premarket-v2.tmp
  2026-01-20-premarket-v2.tmp
```

### 戦略的コンテキストクリア

計画を設定しコンテキストをクリアしたら（Claude Codeのplanモードのデフォルトオプション）、計画から作業できる。実行にはもう関係ない多くの探索コンテキストを蓄積した場合に有用。

**戦略的コンパクト**: 自動コンパクトを無効化。論理的な間隔で手動コンパクトするか、定義した基準に基づいて自動実行または提案するスキルを作成。

### 動的システムプロンプト注入

全てを`CLAUDE.md`（ユーザースコープ）や`.claude/rules/`（プロジェクトスコープ）に入れる代わりに、CLIフラグを使用してコンテキストを動的に注入。

```bash
claude --system-prompt "$(cat memory.md)"
```

作業内容に基づいてセッションごとに異なるコンテキストを読み込める。

**@ファイル参照との違い**:
- `@memory.md`や`.claude/rules/`に配置した場合、Claudeは会話中にReadツールで読み込む（ツール出力として入る）
- `--system-prompt`を使用すると、会話開始前に実際のシステムプロンプトに注入される

違いは**指示の階層**。システムプロンプトコンテンツはユーザーメッセージより高い権限を持ち、ユーザーメッセージはツール結果より高い権限を持つ。

日常的な作業ではこの差は微々たるもの。しかし厳格な行動ルール、プロジェクト固有の制約、Claudeに絶対優先してほしいコンテキストには、システムプロンプト注入が適切な重み付けを保証する。

**実用的なセットアップ**:
```bash
# 日常開発
alias claude-dev='claude --system-prompt "$(cat ~/.claude/contexts/dev.md)"'

# PRレビューモード
alias claude-review='claude --system-prompt "$(cat ~/.claude/contexts/review.md)"'

# リサーチ/探索モード
alias claude-research='claude --system-prompt "$(cat ~/.claude/contexts/research.md)"'
```

**コンテキストファイル例**:
- `dev.md`: 実装に焦点
- `review.md`: コード品質/セキュリティに焦点
- `research.md`: 行動前の探索に焦点

### メモリ永続化フック

メモリに役立つあまり知られていないフック:

```
SESSION 1                    SESSION 2
─────────                    ─────────
[Start]                      [Start]
   │                            │
   ▼                            ▼
┌──────────────┐            ┌──────────────┐
│ SessionStart │ ◄─── reads │ SessionStart │◄── loads previous
│    Hook      │  nothing   │    Hook      │    context
└──────┬───────┘    yet     └──────┬───────┘
       │                           │
       ▼                           ▼
   [Working]                   [Working]
       │                       (informed)
       ▼                           │
┌──────────────┐                   ▼
│  PreCompact  │──► saves     [Continue...]
│    Hook      │  state
└──────┬───────┘  before
       │          summary
       ▼
   [Compacted]
       │
       ▼
┌──────────────┐
│  Stop Hook   │──► persists to ──────────►
│ (session-end)│    ~/.claude/sessions/
└──────────────┘
```

- **PreCompact Hook**: コンテキスト圧縮前に重要な状態をファイルに保存
- **SessionComplete Hook**: セッション終了時に学習をファイルに永続化
- **SessionStart Hook**: 新しいセッションで以前のコンテキストを自動的に読み込み

これらを連鎖させて、手動介入なしでセッション間の継続的なメモリを構築。

---

## Continuous Learning / Memory

codemapを継続的に更新する形での連続メモリ更新について説明したが、これは間違いからの学習など他のことにも適用できる。同じプロンプトを複数回繰り返す必要があり、Claudeが同じ問題に遭遇したり以前に聞いた応答をした場合、これが該当する。

おそらく「軌道修正」してClaudeのコンパスを調整するために2回目のプロンプトを発射する必要があった。これは同様のシナリオ全てに適用される。そのパターンはスキルに追加する必要がある。

Claudeに覚えておくよう伝えるか、ルールに追加するよう伝えることで自動的にこれを行える。または、まさにそれを行うスキルを作成できる。

**問題**: トークンの無駄、コンテキストの無駄、時間の無駄、以前のセッションでやらないよう伝えたことをClaudeがやるとフラストレーションでコルチゾールが上昇。

**解決策**: Claude Codeが些細でないことを発見したとき（デバッグテクニック、ワークアラウンド、プロジェクト固有のパターン）、その知識を新しいスキルとして保存。次に同様の問題が発生したときに自動的に読み込まれる。

### Stopフックを使用する理由

UserPromptSubmitは送信するすべてのメッセージで実行される。オーバーヘッドが多く、すべてのプロンプトにレイテンシが追加され、この目的には過剰。

Stopはセッション終了時に1回実行される。軽量で、セッション中に速度を落とさず、断片的ではなく完全なセッションを評価する。

### /learnによる手動抽出

セッション終了を待つ必要はない。非些細なことを解決したばかりのときにセッション中に実行できる`/learn`コマンドもある。すぐにパターンを抽出するようプロンプトし、スキルファイルのドラフトを作成し、保存前に確認を求める。

### セッションログパターン

スキルは`.tmp`ファイルのセッションログを期待する。パターン:
`~/.claude/sessions/YYYY-MM-DD-topic.tmp` - セッションごとに1ファイル、現在の状態、完了項目、ブロッカー、重要な決定、次のセッションのコンテキストを含む。

### 他の自己改善メモリパターン

**@RLanceMartin**のアプローチ: セッションログを振り返りユーザーの好みを抽出する。基本的に何がうまくいき何がうまくいかないかの「日記」を構築。各セッション後に、振り返りエージェントがうまくいったこと、失敗したこと、行った修正を抽出。これらの学習が後続のセッションで読み込まれるメモリファイルを更新。

**@alexhillman**のアプローチ: パターンに気づくのを待つのではなく、15分ごとに積極的に改善を提案。エージェントが最近のインタラクションをレビューし、メモリ更新を提案し、承認または拒否する。時間とともに承認パターンから学習。

---

## Token Optimization

価格に敏感な消費者やパワーユーザーとして頻繁に制限に遭遇する人からの質問が多い。トークン最適化にはいくつかのトリックがある。

### 主要戦略: サブエージェントアーキテクチャ

主にタスクに十分な最も安価なモデルに委譲するよう設計されたツールとサブエージェントアーキテクチャの最適化で無駄を減らす。

**試行錯誤アプローチ**: 進めながら適応。何がHaikuに委譲でき、何がSonnetに、何がOpusに委譲できるかを学ぶ。

**ベンチマークアプローチ（より複雑）**: 明確に定義された目標とタスクと計画を持つリポジトリでベンチマークをセットアップ。各git worktreeで、全てのサブエージェントを1つのモデルにする。タスク完了をログに記録。各サブエージェントを少なくとも1回は使用する必要がある。

フルパスを完了しタスクがClaude計画からチェックオフされたら、停止して進捗を監査。差分比較、ユニット・インテグレーション・E2Eテストを全worktreeで統一して作成。合格/不合格ケースに基づく数値ベンチマークが得られる。全てで全て合格なら、テストエッジケースを追加するかテストの複雑さを増す必要がある。

### モデル選択クイックリファレンス

| タスク種別 | モデル | 理由 |
|-----------|--------|------|
| 探索/検索 | Haiku | 高速、安価、ファイル検索には十分 |
| 単純な編集 | Haiku | 単一ファイル変更、明確な指示 |
| 複数ファイル実装 | Sonnet | コーディングに最適なバランス |
| 複雑なアーキテクチャ | Opus | 深い推論が必要 |
| PRレビュー | Sonnet | コンテキストを理解、ニュアンスをキャッチ |
| セキュリティ分析 | Opus | 脆弱性を見逃す余裕はない |
| ドキュメント作成 | Haiku | 構造がシンプル |
| 複雑なバグデバッグ | Opus | システム全体を頭に入れる必要がある |

**推奨**: コーディングタスクの90%にSonnetをデフォルトで使用。最初の試行が失敗、タスクが5+ファイルにまたがる、アーキテクチャ決定、セキュリティクリティカルコードの場合にOpusにアップグレード。タスクが反復的、指示が非常に明確、マルチエージェントセットアップの「ワーカー」として使用する場合にHaikuにダウングレード。

**価格** (per MTok):
| モデル | 入力 | 5m Cache Writes | 1h Cache Writes | Cache Hits & Refreshes | 出力 |
|--------|------|-----------------|-----------------|------------------------|------|
| Claude Opus 4.5 | $5 | $6.25 | $10 | $0.50 | $25 |
| Claude Sonnet 4.5 | $3 | $3.75 | $6 | $0.30 | $15 |
| Claude Haiku 4.5 | $1 | $1.25 | $2 | $0.10 | $5 |

正直なところ、Sonnet 4.5は$3入力/$15出力で微妙な位置にある。Opusに対するコスト削減は約66.7%で、絶対的には良い節約だが相対的にはほとんどの人にとって重要ではない。HaikuとOpusの組み合わせが最も理にかなっている。Haiku vs Opusは5倍のコスト差、Sonnetに対しては1.67倍の価格差。

### ツール固有の最適化

Claudeが最も頻繁に呼び出すツールについて考える。例えば、grepをmgrepに置き換える。様々なタスクで従来のgrepやripgrep（Claudeがデフォルトで使用）と比較して平均約半分のトークン削減効果がある。

### バックグラウンドプロセス

該当する場合、Claudeが全出力を処理してライブで直接ストリーミングする必要がない場合は、Claude外でバックグラウンドプロセスを実行。tmuxで簡単に実現可能。ターミナル出力を要約するか、必要な部分だけコピー。入力トークンを大幅に節約できる（コストの大部分は入力トークンから来る - Opus 4.5は100万トークンあたり$5、出力は$25）。

### モジュラーコードベースのメリット

再利用可能なユーティリティ、関数、フックなどを持つよりモジュラーなコードベース。メインファイルが数千行ではなく数百行なら、トークン最適化コストと最初の試行でタスクを正しく完了することの両方に役立ち、相関がある。

Claudeに複数回プロンプトする必要があるなら、特に非常に長いファイルを何度も読み込むとトークンを消費している。ファイルの読み込み完了に多くのツール呼び出しが必要なことに気づくだろう。途中で、ファイルが非常に長いので読み込みを続けることを知らせてくる。このプロセスのどこかで、Claudeは情報を失う可能性がある。また、停止して再読み込みは追加トークンがかかる。これはよりモジュラーなコードベースで回避できる。

**モジュラーコードベース構造例**:
```
root/
├── docs/                    # グローバルドキュメント
├── scripts/                 # CI/CDとビルドスクリプト
├── src/
│   ├── apps/                # エントリーポイント（API、CLI、Workers）
│   │   ├── api-gateway/     # モジュールへリクエストをルーティング
│   │   └── cron-jobs/
│   │
│   ├── modules/             # システムのコア
│   │   ├── ordering/        # 自己完結型「Ordering」モジュール
│   │   │   ├── api/         # 他モジュール向けパブリックインターフェース
│   │   │   ├── domain/      # ビジネスロジック＆エンティティ（純粋）
│   │   │   ├── infrastructure/  # DB、外部クライアント、リポジトリ
│   │   │   ├── use-cases/   # アプリケーションロジック（オーケストレーション）
│   │   │   └── tests/       # ユニット・インテグレーションテスト
│   │   │
│   │   ├── catalog/         # 自己完結型「Catalog」モジュール
│   │   └── identity/        # 自己完結型「Auth/User」モジュール
│   │
│   ├── shared/              # 全モジュールで使用するコード
│   │   ├── kernel/          # ベースクラス（Entity、ValueObject）
│   │   ├── events/          # グローバルEvent Bus定義
│   │   └── utils/           # 汎用ヘルパー
│   │
│   └── main.ts              # アプリケーションブートストラップ
├── tests/                   # E2Eグローバルテスト
└── package.json
```

### リーンなコードベース = 安価なトークン

明らかかもしれないが、コードベースがリーンであればあるほどトークンコストが安くなる。スキルを使用してデッドコードを特定し、スキルとコマンドを使用してリファクタリングすることでコードベースを継続的にクリーンアップすることが重要。

また、特定のポイントでコードベース全体を見渡し、目立つものや反復的に見えるものを探し、そのコンテキストを手動でまとめ、リファクタースキルとデッドコードスキルと一緒にClaudeに入力することを好む。

### システムプロンプトスリム化（上級）

本当にコストを意識する人向け: Claude Codeのシステムプロンプトは約18kトークン（200kコンテキストの約9%）を消費。パッチで約10kトークンに削減可能で、約7,300トークン（静的オーバーヘッドの41%）を節約。

---

## Verification Loops and Evals

評価とハーネスチューニング - プロジェクトによっては、何らかの可観測性と標準化を使用したい。

### 可観測性メソッド

スキルがトリガーされるたびにthinkingストリームと出力をトレースするtmuxプロセスをフックする方法がある。別の方法として、Claudeが具体的に何を実行し、正確な変更と出力が何だったかをログするPostToolUseフックがある。

### ベンチマークワークフロー

スキルなしで同じことを要求し、出力差分をチェックして相対的なパフォーマンスをベンチマーク:

```
         [Same Task]
              │
     ┌────────┴────────┐
     ▼                 ▼
┌───────────────┐ ┌───────────────┐
│  Worktree A   │ │  Worktree B   │
│  WITH skill   │ │ WITHOUT skill │
└───────┬───────┘ └───────┬───────┘
        │                 │
        ▼                 ▼
    [Output A]        [Output B]
        │                 │
        └────────┬────────┘
                 ▼
            [git diff]
                 │
                 ▼
       ┌────────────────┐
       │  Compare logs, │
       │  token usage,  │
       │  output quality│
       └────────────────┘
```

会話をフォークし、一方にスキルなしで新しいworktreeを開始し、最後に差分を出し、何がログされたか確認。

### 評価パターンタイプ

分割は、チェックポイントベースの評価とRLタスクベースの継続的評価の間。

```
CHECKPOINT-BASED             CONTINUOUS
─────────────────            ──────────
  [Task 1]                     [Work]
     │                           │
     ▼                           ▼
 ┌─────────┐               ┌─────────┐
 │Checkpoint│◄── verify    │ Timer/  │
 │   #1    │   criteria    │ Change  │
 └────┬────┘               └────┬────┘
      │ pass?                   │
  ┌───┴───┐                     ▼
  │       │              ┌──────────┐
 yes     no──► fix──┐    │Run Tests │
  │             │   │    │  + Lint  │
  ▼             └───┘    └────┬─────┘
[Task 2]                      │
  │                     ┌────┴────┐
  ▼                     │         │
┌─────────┐           pass      fail
│Checkpoint│            │         │
│   #2    │            ▼         ▼
└────┬────┘       [Continue] [Stop & Fix]
     │                        │
    ...                       └───┘

Best for: Linear workflows   Best for: Long sessions
with clear milestones        exploratory refactoring
```

### チェックポイントベース評価

- ワークフローに明示的なチェックポイントを設定
- 各チェックポイントで定義された基準に対して検証
- 検証に失敗したら、Claudeは先に進む前に修正する必要がある
- 明確なマイルストーンを持つ線形ワークフローに適している

### 継続的評価

- N分ごとまたはメジャー変更後に実行
- フルテストスイート、ビルドステータス、lint
- 即座にリグレッションを報告
- 続行前に停止して修正
- 長時間実行セッションに適している

**決定要因**: 作業の性質。チェックポイントベースは明確なステージを持つ機能実装向け。継続的は明確なマイルストーンがない探索的リファクタリングやメンテナンス向け。

### グレーダータイプ（Anthropicより）

**コードベースグレーダー**: 文字列マッチ、バイナリテスト、静的分析、結果検証。高速、安価、客観的だが、有効なバリエーションに脆弱。

**モデルベースグレーダー**: ルーブリックスコアリング、自然言語アサーション、ペアワイズ比較。柔軟でニュアンスを扱えるが、非決定的でより高価。

**人間グレーダー**: SMEレビュー、クラウドソースド判断、スポットチェックサンプリング。ゴールドスタンダード品質だが、高価で遅い。

### 主要メトリクス

```
pass@k: k回の試行のうち少なくとも1回成功
     ┌─────────────────────────────────────┐
     │ k=1: 70%  k=3: 91%  k=5: 97%        │
     │ 高いk = 成功確率が高い              │
     └─────────────────────────────────────┘

pass^k: k回の試行全て成功する必要あり
     ┌─────────────────────────────────────┐
     │ k=1: 70%  k=3: 34%  k=5: 17%        │
     │ 高いk = より難しい（一貫性）        │
     └─────────────────────────────────────┘
```

動作すればよく、検証フィードバックがあれば十分な場合は**pass@k**を使用。一貫性が重要で、ほぼ決定論的な出力の一貫性（結果/品質/スタイルの面で）が必要な場合は**pass^k**を使用。

### 評価ロードマップ構築（同じAnthropicガイドより）

1. 早期に開始 - 実際の失敗から20-50のシンプルなタスク
2. ユーザー報告の失敗をテストケースに変換
3. 曖昧さのないタスクを書く - 2人の専門家が同じ判定に達するべき
4. バランスの取れた問題セットを構築 - 動作すべき時とすべきでない時の両方をテスト
5. 堅牢なハーネスを構築 - 各試行はクリーンな環境から開始
6. エージェントが生成したものを評価、取った経路ではなく
7. 多くの試行からトランスクリプトを読む
8. 飽和を監視 - 100%合格率はテスト追加が必要を意味

---

## Parallelization

マルチClaude端末セットアップで会話をフォークする場合、フォークと元の会話でのアクションのスコープが明確に定義されていることを確認。コード変更に関しては重複を最小限に。干渉の可能性を防ぐため、互いに直交するタスクを選択。

### 推奨パターン

個人的には、メインチャットがコード変更に取り組み、フォークはコードベースとその現状についての質問、またはドキュメントの取り込み、タスクに役立つ適用可能なオープンソースリポジトリのGitHub検索、その他の一般的なリサーチなど外部サービスでのリサーチに使用することを好む。

### 任意の端末数について

**注意**: 5つのローカルClaudeインスタンスと5つのアップストリームのような任意の端末数を設定することは推奨しない。端末とインスタンスの追加は、真の必要性と目的から出るべき。スクリプトでそのタスクを処理できるならスクリプトを使用。メインチャットに留まり、Claudeにtmuxでインスタンスを起動させ別の端末でストリームさせることができるならそうする。

**目標**: 最小限の並列化で最大限のことを達成する。

初心者には、単一インスタンスの実行と管理に慣れるまで並列化を避けることを推奨。ハンディキャップを推奨しているわけではない。注意すべきと言っている。ほとんどの場合、4端末程度しか使用しない。通常2-3個のClaudeインスタンスでほとんどのことができる。

### インスタンスをスケールする場合

インスタンスをスケールし始め、かつ複数のClaudeインスタンスが互いに重複するコードで作業している場合、git worktreesを使用し、各々に非常に明確な計画を持つことが不可欠。

さらに、どのgit worktreeが何のためか（ツリーの名前以外で）混乱したり迷子にならないよう、セッション再開時に`/rename <name here>`で全チャットに名前を付ける。

### 並列インスタンス用Git Worktrees

```bash
# 並列作業用worktreeを作成
git worktree add ../project-feature-a feature-a
git worktree add ../project-feature-b feature-b
git worktree add ../project-refactor refactor-branch

# 各worktreeで独自のClaudeインスタンスを実行
cd ../project-feature-a && claude
```

**メリット**:
- インスタンス間でgitコンフリクトなし
- 各々がクリーンな作業ディレクトリを持つ
- 出力の比較が容易
- 異なるアプローチで同じタスクをベンチマーク可能

### カスケードメソッド

複数のClaude Codeインスタンスを実行する場合、「カスケード」パターンで整理:
- 新しいタスクは右側の新しいタブで開く
- 左から右へスイープ、古いものから新しいものへ
- 一貫した方向フローを維持
- 必要に応じて特定のタスクをチェック
- 最大3-4タスクに集中 - それ以上は生産性より精神的オーバーヘッドが速く増加

---

## Best Practices for Agents & Sub-Agents

### サブエージェントコンテキスト問題

サブエージェントは全てをダンプする代わりに要約を返すことでコンテキストを節約するために存在する。しかし、オーケストレーターにはサブエージェントにない意味的コンテキストがある。サブエージェントはリクエストの背後にある目的/理由ではなく、文字通りのクエリのみを知っている。要約はしばしば重要な詳細を見逃す。

**@PerceptualPeakからのアナロジー**: 「上司があなたを会議に送り、要約を求める。戻って概要を伝える。10回中9回、フォローアップの質問がある。あなたの要約は彼が必要とする全てを含まない。なぜなら彼が持つ暗黙のコンテキストを持っていないから。」

### 反復的取得パターン

```
┌─────────────────┐
│  ORCHESTRATOR   │
│  (has context)  │
└────────┬────────┘
         │ dispatch with query + objective
         ▼
┌─────────────────┐
│   SUB-AGENT     │
│  (lacks context)│
└────────┬────────┘
         │ returns summary
         ▼
┌─────────────────┐      ┌─────────────┐
│    EVALUATE     │─no──►│  FOLLOW-UP  │
│   Sufficient?   │      │  QUESTIONS  │
└────────┬────────┘      └──────┬──────┘
         │ yes                  │
         ▼                      │ sub-agent
     [ACCEPT]               fetches answers
         │                      │
         ◄──────────────────────┘
           (max 3 cycles)
```

これを修正するため、オーケストレーターに:
- 全てのサブエージェントの返却を評価させる
- 受け入れる前にフォローアップの質問をさせる
- サブエージェントがソースに戻り、回答を得て、返す
- 十分になるまでループ（無限ループ防止のため最大3サイクル）

**クエリだけでなく目的コンテキストを渡す**: サブエージェントをディスパッチする際、具体的なクエリと広い目的の両方を含める。これによりサブエージェントが要約に何を含めるか優先順位付けできる。

### パターン: シーケンシャルフェーズを持つオーケストレーター

```
Phase 1: RESEARCH (use Explore agent)
- コンテキストを収集
- パターンを特定
- 出力: research-summary.md

Phase 2: PLAN (use planner agent)
- research-summary.mdを読む
- 実装計画を作成
- 出力: plan.md

Phase 3: IMPLEMENT (use tdd-guide agent)
- plan.mdを読む
- 最初にテストを書く
- コードを実装
- 出力: コード変更

Phase 4: REVIEW (use code-reviewer agent)
- 全変更をレビュー
- 出力: review-comments.md

Phase 5: VERIFY (use build-error-resolver if needed)
- テストを実行
- 問題を修正
- 出力: 完了またはループバック
```

**主要ルール**:
1. 各エージェントは1つの明確な入力を受け取り、1つの明確な出力を生成
2. 出力が次のフェーズの入力になる
3. フェーズをスキップしない - 各々が価値を追加
4. エージェント間で`/clear`を使用してコンテキストを新鮮に保つ
5. 中間出力をファイルに保存（メモリだけでなく）

### エージェント抽象化ティアリスト（@menhuguinより）

**Tier 1: 直接バフ（使いやすい）**
- **サブエージェント**: コンテキスト腐敗防止とアドホック特化への直接バフ。マルチエージェントの半分ほど有用だがはるかに複雑さが少ない
- **メタプロンプティング**: 「20分のタスクをプロンプトするのに3分かける」。直接バフ - 安定性を向上し仮定をサニティチェック
- **最初にユーザーにもっと質問**: 一般的にバフだが、planモードで質問に答える必要がある

**Tier 2: 高スキル床（うまく使うのが難しい）**
- **長時間実行エージェント**: 15分タスク vs 1.5時間 vs 4時間タスクの形状とトレードオフを理解する必要がある。調整が必要で、明らかに非常に長い試行錯誤
- **並列マルチエージェント**: 非常に高い分散、非常に複雑またはセグメント化されたタスクでのみ有用。「2つのタスクが10分かかり、プロンプトに任意の時間を費やし、まして変更をマージするなら、非生産的」
- **ロールベースマルチエージェント**: 「モデルは進化が速すぎて、裁定取引が非常に高くない限りハードコードされたヒューリスティクスには向かない」。テストが難しい
- **Computer Useエージェント**: 非常に早期のパラダイム、調整が必要。「1年前にはやることさえ意図されていなかったことをモデルにさせている」

**結論**: Tier 1パターンから始める。基本をマスターし、真の必要性がある場合のみTier 2に進む。
